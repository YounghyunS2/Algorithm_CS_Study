
## 3.3.4 PCB

 **운영체제가 프로세스를 하나 만들어서 실행을 하려면** 그 프로세스와 관련된 데이터 구조가 당연히 있어야 할 것이고, 프로세스의 기본 정보가 저장될 곳이 필요함 → **PCB(Process control block)**

PCB(Process Control Block): 운영체제에서 프로세스에 대한 메타데이터를 저장한 ‘데이터’


💡  **메타데이터**
데이터에 관한 구조화된 데이터, 데이터를 설명하는 작은 데이터, 대량의 정보 가운데에서 찾고 있는 정보를 효율적으로 찾아내서 이용하기 위해 일정한 규칙에 따라 콘텐츠에 대해 부여되는 데이터



**프로세스 제어 블록**이라고도 한다

- 운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓는 곳으로, **프로세스의 상태 정보를 저장하는 구조체**

과정: 프로그램 실행 → 프로세스 생성 → 메모리 할당, 프로세스의 메타데이터들이 PCB에 저장되어 관리됨

프로세스의 중요한 정보를 포함 → 일반 사용자가 접근하지 못하도록 커널 스택의 가장 앞부분에서 관리됨

- 프로세스 상태 관리와 **문맥교환(Context Switching)** 을 위해 필요
- PCB는 프로세스 생성 시 만들어지며 주기억장치에 유지

**프로세스를 PCB 단위로 관리**하며 프로세스 스케줄링을 위한 정보를 PCB를 통해 관리

### 관리 방식

**연결 리스트 방식**으로 관리된다.

삽입 삭제가 용이하며 프로세스가 생성 되면 해당 PCB가 생성되고, 프로세스가 완료되면 제거된다.

### PCB의 구조

- **프로세스 스케줄링 상태**
    - ‘준비’, ‘일시중단’ 등 프로세스가 CPU에 대한 소유권을 얻은 이후의 상태
- **프로세스 ID**
    - 프로세스를 구분하는 ID, 해당 프로세스의 자식 프로세스 ID
- **프로세스 권한**
    - 컴퓨터 자원 또는 I/O 디바이스에 대한 권한 정보
- **프로그램 카운터**
    - 프로세스에서 실행해야 할 **다음 명령어의 주소**에 대한 포인터
    - CPU가 이 값을 통해 Process의 Instruction 수행
- **CPU 레지스터**
    - 프로세스를 실행하기 위해 저장해야 할 레지스터에 대한 정보
- **CPU 스케줄링 정보**
    - CPU 스케줄러에 의해 중단된 시간 등에 대한 정보
    - 우선 순위, 최종 실행 시간, CPU 점유 시간 등이 포함
- **********************메모리 정보**********************
    - 해당 프로세스 주소공간 (lower bound~upper bound) 정보를 저장
- **계정 정보**
    - 프로세스 실행에 사용된 CPU 사용량, 실행한 유저의 정보
- **I/O 상태 정보**
    - 프로세스에 할당된 I/O 디바이스 정보
    - 프로세스에 할당된 입출력 장치 목록 등
- **Open File List**
    - 프로세스를 위해 열려 있는 파일의 리스트

### 컨텍스트 스위칭(Context Switching)

<aside>
💡 PCB를 교환하는 과정

</aside>
<br>
<aside>
💡 CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다르 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정

</aside>

한 프로세스에 할당된 시간이 끝나거나 인터럽트에 의해 발생

한 시점에서 실행되고 있는 프로세스는 단 한개, 다른 프로세스와의 컨텍스트 스위칭이 아주 빠른 속도로 실행됨 (싱글 코어 기준)

cf. 레지스터: CPU 내부에 존재, 프로그램 카운터, 스택 포인터 등

현재 수행중인 프로세스의 정보는 레지스터에 저장되어 있음 → PCB라는 저장 공간이 필요X

인터럽트가 걸리면 현재 수행되는 프로세스를 저장 

→ CPU가 다른 프로세스를 running으로 바꾼다

→ **CPU의 레지스터 값이 다른 프로세스로 바뀌기 전에 저장해야 한다: PCB에 저장**

![9D141ABE-DED3-4BEF-B40F-136CB47C86D2.jpeg](./img/ch3.3.4_1.jpeg)

- 유휴 시간(idle time) 발생

비용: 캐시미스

- 컨텍스트 스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그대로 있으면 잘못된 주소 변환이 생김 → **캐시 클리어 → 캐시 미스 발생**

### 오버헤드

> 문맥교환에 소요되는 시간과 메모리를 의미
> 

문맥교환이 발생하면 시간과 메모리가 소요되므로 **잦은 문맥교환→ 성능 저하**

I/O 이벤트가 발생했을 때, 해당 이벤트가 끝날 때 까지 기다리면 CPU를 점유하고 있어도 아무런 작업도 할 수 없기 때문에 CPU가 낭비된다.

때문에 오버헤드를 감수하면서 기존 프로세스를 새 프로세스로 바꾸는 것이 더 효율적이다.


💡 **시간 할당량**

프로세스가 작동하다가 시간 할당량을 초과하면 현재 프로세스가 끝나지 않았음에도 다음 프로세스로 넘어간다



- 시간 할당량이 적어지면 문맥 교환의 수와 오버헤드가 증가, 더 많은 프로세스를 수행
- 시간 할당량이 커지면 문맥 교환의 수와 오버헤드 감소, 더 적은 프로세스를 동시에 수행

### 스레드에서의 컨텍스트 스위칭

스레드: 스택 영역을 제외한 모든 메모리를 공유, 스레드 컨텍스트 스위칭이 비용도 더 적고 시간도 더 적게 걸림

---

[https://jhnyang.tistory.com/33](https://jhnyang.tistory.com/33)

[https://jins-dev.tistory.com/entry/PCBProcess-Control-Block-개념-정리](https://jins-dev.tistory.com/entry/PCBProcess-Control-Block-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)

[https://velog.io/@klloo/운영체제-PCB와-Context-Switching](https://velog.io/@klloo/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-PCB%EC%99%80-Context-Switching)
